package io.nuls.transaction.service;

import io.nuls.base.data.BlockHeader;
import io.nuls.base.data.NulsHash;
import io.nuls.base.data.Transaction;
import io.nuls.core.exception.NulsException;
import io.nuls.transaction.model.bo.Chain;
import io.nuls.transaction.model.bo.TxPackage;
import io.nuls.transaction.model.bo.TxRegister;
import io.nuls.transaction.model.bo.VerifyResult;
import io.nuls.transaction.model.dto.ModuleTxRegisterDTO;
import io.nuls.transaction.model.po.TransactionConfirmedPO;
import io.nuls.transaction.model.po.TransactionNetPO;

import java.util.List;
import java.util.Map;

/**
 * @author: Charlie
 * @date: 2018/11/22
 */
public interface TxService {

    /**
     * Registration transaction
     * Register transaction
     *
     * @param chain
     * @param moduleTxRegisterDto
     * @return boolean
     */
    boolean register(Chain chain, ModuleTxRegisterDTO moduleTxRegisterDto);

    /**
     * Received a new transaction
     * Received a new transaction
     *
     * @param tx
     * @return boolean
     * @throws NulsException NulsException
     */
    void newBroadcastTx(Chain chain, TransactionNetPO tx);


    /**
     * New transactions generated by nodes,The transaction has been verified through validator and ledger verification,Can be placed in the queue for packaging and unconfirmed storage
     * @param chain
     * @param transaction
     * @throws NulsException
     */
    void newTx(Chain chain, Transaction transaction) throws NulsException;


    /**
     * Verify transactions
     * @param chain
     * @param tx
     * @return
     */
    VerifyResult verify(Chain chain, Transaction tx);

    /**
     * Basic transaction verification
     *
     * @param chain
     * @param tx
     * @param txRegister
     * @throws NulsException
     */
    void baseValidateTx(Chain chain, Transaction tx, TxRegister txRegister) throws NulsException;

    /**
     * Get a transaction, first check the database from the confirmation transaction,
     * if not found, then query from the confirmed transaction
     *
     * Get a transaction, First, query in the unconfirmed transaction database, If not found, search from the confirmed transactions again
     *
     * @param chain chain
     * @param hash  tx hash
     * @return Transaction If not found, returnnull
     */
    TransactionConfirmedPO getTransaction(Chain chain, NulsHash hash);

    /**
     * Check if the transaction exists, first check in the unconfirmed database, and then check from the confirmed database
     * @param chain
     * @param hash
     * @return
     */
    boolean isTxExists(Chain chain, NulsHash hash);

    /**
     *  Consensus packaging to obtain the required transactions for packaging
     * @param chain
     * @param endtimestamp Obtain transaction deadline
     * @param maxTxDataSize
     * @param blockTime Block time
     * @param packingAddress
     * @param preStateRoot
     * @return
     */
    TxPackage getPackableTxs(Chain chain, long endtimestamp, long maxTxDataSize, long blockTime,
                             String packingAddress, String preStateRoot);

    TxPackage getPackableTxsV8(Chain chain, long endtimestamp, long maxTxDataSize, long blockTime,
                             String packingAddress, String preStateRoot);

    /**
     * When receiving the New Area Express, verify the complete transaction list
     * @param chain
     * @param list
     * @param preStateRoot
     * @return
     * @throws NulsException
     */
    Map<String, Object> batchVerify(Chain chain, List<String> list, BlockHeader blockHeader, String blockHeaderStr, String preStateRoot) throws Exception;

    Map<String, Object> batchVerifyV8(Chain chain, List<String> list, BlockHeader blockHeader, String blockHeaderStr, String preStateRoot) throws Exception;



    /**
     * Delete a single invalid transaction from a verified unpackaged transaction(asynchronous)
     *
     * @param chain
     * @param tx
     * @return
     */
    void clearInvalidTx(Chain chain, Transaction tx);

    /**
     * Delete a single invalid transaction from a verified unpackaged transaction(asynchronous)
     * @param chain
     * @param tx
     * @param changeStatus
     */
    void clearInvalidTx(Chain chain, Transaction tx, boolean changeStatus);

}
